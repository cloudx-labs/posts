---
title: EF Core Simplify your queries with AutoMapper
published: true
description: Simplify EF core queries with AutoMapper
tags: 'net, entity-framework, automapper'
cover_image: ./assets/1-automapper-cover.png
---

For the examples of code, we are going to use the following entities.

```c#
    public class Blog
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public ICollection<Post> Posts { get; set; }
    }

    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public Blog Blog { get; set; }
        public List<Comment> Comments { get; set; }
    }

    public class Comment
    {
        public int Id { get; set; }
        public string Content { get; set; }
        public Post Post { get; set; }
    }
```

And DTOs

```c#
    public class PostDto
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public int BlogId { get; set; }
        public string BlogName { get; set; }
        public List<CommentDto> CommentsDto { get; set; }
    }

    public class CommentDto
    {
        public int Id { get; set; }
        public string Content { get; set; }
    }

    public class PostSummaryDto
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public int CommentsCount { get; set; }
    }
```

When querying data with Entity Framework is very common to query data using the Include method, and then manually map the collection of posts to a collection of `PostDto`:

```c#
  var posts = dbContext.Posts
      .Include(x => x.Blog)
      .Include(x => x.Comments)
      .ToListAsync();

 // manually map to DTO     
```

Entity Framework will generate the following query:

```SQL
    SELECT [p].[Id], [p].[BlogId], [p].[Title], [b].[Id], [b].[Name], 
    [c].[Id], [c].[Content], [c].[PostId]
    FROM [Posts] AS [p]
    INNER JOIN [Blogs] AS [b] ON [p].[BlogId] = [b].[Id]
    LEFT JOIN [Comments] AS [c] ON [p].[Id] = [c].[PostId]
    ORDER BY [p].[Id], [b].[Id]
```

Or if you use AutoMapper, you'll probably do something like this instead:

```c#
  var posts = dbContext.Posts
      .Include(x => x.Blog)
      .Include(x => x.Comments)
      .ToListAsync();
  var collectionOfPostDto = mapper.Map<PostDto>(posts);
```

Obviously generating the same SQL query.

You can do the same using an Entity Framework projection, just picking the fields that you need:

```c#
    var post = dbContext.Posts
        .Select(x => new PostDto()
        {
            Id = x.Id,
            Title = x.Title,
            BlogId = x.Blog.Id,
            BlogName = x.Blog.Name,
            CommentsDto = x.Comments.Select(c => new CommentDto()
            {
                Id = c.Id,
            }).ToList()
        })
        .ToListAsync();
```

With the following query as the result:

```SQL
    SELECT [p].[Id], [p].[Title], [b].[Id], [b].[Name], [c].[Id]
    FROM [Posts] AS [p]
    INNER JOIN [Blogs] AS [b] ON [p].[BlogId] = [b].[Id]
    LEFT JOIN [Comments] AS [c] ON [p].[Id] = [c].[PostId]
    ORDER BY [p].[Id], [b].[Id]
```

### ProjectTO to the rescue

AutoMapper has a simple way to solve this:

```c#
   var posts = mapper.ProjectTo<PostDto>(dbContext.Posts, null).ToListAsync();
```

Generating exactly the same query as the projection:

```SQL
    SELECT [p].[Id], [p].[Title], [b].[Id], [b].[Name], [c].[Id]
    FROM [Posts] AS [p]
    INNER JOIN [Blogs] AS [b] ON [p].[BlogId] = [b].[Id]
    LEFT JOIN [Comments] AS [c] ON [p].[Id] = [c].[PostId]
    ORDER BY [p].[Id], [b].[Id]
```

_The `.ProjectTo<PostDto>()` will tell AutoMapper's mapping engine to emit a select clause to the IQueryable that will inform Entity Framework that it only needs to query the fields presents in the DTO._

The common case for the `ProjectTo` is using small DTOs/models. e.g:

```c#
    public class PostSummaryDto
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public int CommentsCount { get; set; }
    }
```

And writing again only 1 line on C#:

```c#
    var postSummary = mapper.ProjectTo<PostSummaryDto>(dbContext.Posts, null).ToListAsync();
```

The SQL code looks really nice:

```SQL
    SELECT [p].[Id], [p].[Title], (
        SELECT COUNT(*)
        FROM [Comments] AS [c]
        WHERE [p].[Id] = [c].[PostId]) AS [CommentsCount]
    FROM [Posts] AS [p]
```

As we can see we can have a very performant query just using 1 line of code. If you want to read more about  `.ProjectTo` please read [here](https://docs.automapper.org/en/stable/Queryable-Extensions.html).
