---
title: "The forwarder pattern"
published: false
description: Second chapter to build a payments gateway powered by smart contracts
tags: "ethereum, solidity, openzeppelin, payments"
cover_image: ./assets/05.cover.png
series: "Your own payments gateway, powered by smart contracts"
---

## The problem

When we started building our own payments gateway, the main goal to accomplish is that we needed to be able to receive payments in multiple tokens, ERC20 specifically. We also wanted to be able to support new currencies that implement the same interface in the future without having to change our code.

One aspect of an address in ethereum world is that they are not able to have other addresses as alias, as happens on Bitcoin with the concept of Vanity Address, meaning that there is not an easy way of linking a payment or transaction with a specific user, so we don't know if a user has paid or not for something the have bought; unless the user is connected via a wallet like Metamask or WalletConnect (this is how DApps solve this issue). The main focus to solve is to make it easy for users to make the payments, we will solve this generating unique address for each required payment before hand, deploying a contract to this address and then the gateway (deployer of that address) will be able to forward any received payment (tokens) made to that address. This is the main idea behind the forwarder contracts pattern.

### We need "unique addresses to identify users payments"

If all the interaction with the smart contract is done via a DApp, users just need to interact with the smart contract methods via any web3 library from our application, identifying them self while signing transactions without leaving the app. But what about if the user is not using a DApp? or a mobile native application without support for external wallets?, users will need to send payment to an address for an amount, this address will need to be unique for each user and for each payment so we can identify what user is paying for what service. Ethereum addresses are not able to have aliases, so we need to create and "pre-deploy" a smart contracts to handle this.

### â™º When funds are received, "forward the payments"

The other aspect of the problem is we need to be able to forward the payment to the final destination. This is not a problem if the payment is done in ETH, because we can just use the `transfer` method of the address. But if the payment is done in any other ERC20 tokens, then we need to use the `transferFrom` method of that specific ERC20 token contract that we want to move, this method requires an allowance that needs to exists inside the contract before we can request the transfer; so, instead of having the user to set the allowance to the gateway address and dealing with other ERC20 implemented methods, we can ask our client user to send any ERC20 token to an generated address (forwarder contract), and then the forwarder contract will be able to "flush" the payment to the final destination, evading the complexity of dealing with ERC20 tokens.

The forwarder smart contract will behave like a box where we can put any tokens in, and then its parent (the wallet that created it) will request the forwarder to move those tokens by specifying the ERC20 token contract address of the token we want to move, interacting with it via its implementation, here's quick example of how this can be done:

```solidity
// ... forwarder contract
function flushTokens(address _token) external virtual onlyOwner {
  // create an instance of the token contract using the address of token, can be USDC, USDT, DAI, etc.
  IERC20Upgradeable token = IERC20Upgradeable(_token);

  // verify the balance of the forwarder contract (this) inside the token contract (ERC20)
  address forwarderAddress = address(this);
  uint256 forwarderBalance = token.balanceOf(forwarderAddress);
  if (forwarderBalance == 0) {
    return;
  }

  // transfer all funds of token to the gateway address (parent / deployer)
  TransferHelper.safeTransfer(_token, gatewayAddress, forwarderBalance);
  emit FundsTransferred(forwarderAddress, gatewayAddress, forwarderBalance);
}
```

As the forwarder contract needs to be unique as will be used to identify user payments, we need a quick way of knowing which will be the final deposit address without deploying the contract, this is due to deploying a smart contract requires a delay and small wait while the changes are deployed and settled in the blockchain, so being able to know the final address that our contract will have before hand creates the possibility of generate those address quickly and cost efficient without delay, this can be archived in ethereum via the concept of [CREATE2](https://eips.ethereum.org/EIPS/eip-1014); the `CREATE2` opcode gives us the ability "predict" the address where a contract will be deployed, without ever having to do so, predicting the address of the forwarder contract will allow us to know the deposit address needed for a user payment without having to deploy the contract and wait for the transaction to be mined ðŸ¤¯.

So the `Gateway` contract previously created in [the first chapter](https://dev.to/cloudx/upgradeable-smart-contracts-29d9) will handle two new methods:

1. `computeAddress`: This method will compute the address of the forwarder contract for a given user.
2. `deployForwarder`: This method will deploy the forwarder contract for a given user address.
   qvp

We will create those contract under the concept of upgradeability using [OpenZeppelin implementation](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies).
